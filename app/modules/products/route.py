from fastapi import APIRouter, Depends, Query, Form, File, UploadFile
from sqlalchemy.orm import Session
from uuid import UUID
from typing import List, Optional
import json
from app.config.deps import get_db, get_current_user, CurrentUser
from app.modules.products.schema import ProductCreateSchema, ProductUpdateSchema
from app.modules.products.controller import ProductController

router = APIRouter()


@router.post("/", summary="Create new product with file uploads")
async def create_product(
    # Form fields (all as Form, not JSON)
    name: str = Form(..., description="Product name"),
    product_type: str = Form("SIMPLE", description="SIMPLE or VARIABLE"),
    base_price: float = Form(..., description="Base price/COGS"),
    selling_price: float = Form(..., description="Selling price"),

    # Optional fields
    description: Optional[str] = Form(None),
    category_id: Optional[str] = Form(None),
    qty: Optional[int] = Form(None),
    min_stock: Optional[int] = Form(None),
    max_stock: Optional[int] = Form(None),
    weight: Optional[float] = Form(None),
    length: Optional[float] = Form(None),
    width: Optional[float] = Form(None),
    height: Optional[float] = Form(None),
    is_active: bool = Form(True),
    is_featured: bool = Form(False),
    track_inventory: bool = Form(True),

    # For VARIABLE products: JSON strings for complex nested data
    attributes: Optional[str] = Form(None, description="JSON array of attributes"),
    variants: Optional[str] = Form(None, description="JSON array of variants"),

    # Files
    main_images: List[UploadFile] = File(..., description="Product images (minimum 1 required)"),
    variant_images: Optional[List[UploadFile]] = File(None),

    # Other
    business_id: UUID = Query(...),
    db: Session = Depends(get_db),
    current_user: CurrentUser = Depends(get_current_user)
):
    """
    Create product with multipart/form-data.

    **Note:** SKU is auto-generated by the system based on product_code or variant_code.

    **For SIMPLE product:**
    - name, base_price, selling_price, qty, etc
    - main_images: File[]
    - SKU will be auto-generated as: SKU-{business_code}-PROD-{sequence}

    **For VARIABLE product:**
    - name, base_price, selling_price, etc
    - attributes: JSON string '[{"attribute_name":"Size","values":[{"value":"S"}]}]'
    - variants: JSON string '[{"attribute_values":{"Size":"S"},"qty":10}]'
    - main_images: File[]
    - variant_images: File[] (with naming: variant_0_img.jpg)
    - Variant SKUs will be auto-generated as: SKU-{business_code}-PROD-{sequence}-VAR-{variant_sequence}
    """
    return await ProductController.create_product_with_form(
        name=name,
        product_type=product_type,
        base_price=base_price,
        selling_price=selling_price,
        description=description,
        category_id=category_id,
        qty=qty,
        min_stock=min_stock,
        max_stock=max_stock,
        weight=weight,
        length=length,
        width=width,
        height=height,
        is_active=is_active,
        is_featured=is_featured,
        track_inventory=track_inventory,
        attributes=attributes,
        variants=variants,
        main_images=main_images,
        variant_images=variant_images,
        business_id=business_id,
        user_id=current_user.user_id,
        created_by=current_user.email,
        db=db
    )


@router.get("/", summary="Get all products for a business with advanced filtering")
def get_products(
    search: Optional[str] = Query(None, description="Search keyword (searches all fields)"),
    sort_by: Optional[str] = Query(None, description="Field name to sort by"),
    sort_order: str = Query("desc", description="Sort order: asc or desc"),
    page: Optional[int] = Query(None, ge=1, description="Page number (1-based)"),
    per_page: Optional[int] = Query(None, ge=1, le=100, description="Items per page"),
    db: Session = Depends(get_db),
):
    """
    Get all products for a specific business with advanced filtering, search, sorting, and pagination.

    **Features:**
    - Search across all fields (name, description, SKU, etc.)
    - Sort by any field (created_at, name, price, etc.)
    - Pagination support
    - Includes all related data:
      - Product images
      - Variants with their images
      - Attributes with values
      - Attribute mappings

    **Example:**
    - `/products?business_id={id}&search=kemeja&page=1&per_page=20&sort_by=name&sort_order=asc`
    """
    return ProductController.get_products_by_business(
        search=search,
        sort_by=sort_by,
        sort_order=sort_order,
        page=page,
        per_page=per_page,
        db=db
    )


@router.get("/{product_id}", summary="Get product by ID")
def get_product(
    product_id: UUID,
    business_id: UUID = Query(..., description="Business ID"),
    db: Session = Depends(get_db),
):
    """
    Get a specific product by ID within a business.
    """
    return ProductController.get_product_by_id(
        product_id=product_id,
        business_id=business_id,
        db=db
    )


@router.put("/{product_id}", summary="Update product with file uploads (full replace)")
async def update_product(
    product_id: UUID,
    # Form fields (all as Form, not JSON)
    name: str = Form(..., description="Product name"),
    product_type: str = Form(..., description="SIMPLE or VARIABLE (must match original)"),
    base_price: float = Form(..., description="Base price/COGS"),
    selling_price: float = Form(..., description="Selling price"),

    # Optional fields
    description: Optional[str] = Form(None),
    category_id: Optional[str] = Form(None),
    qty: Optional[int] = Form(None),
    min_stock: Optional[int] = Form(None),
    max_stock: Optional[int] = Form(None),
    weight: Optional[float] = Form(None),
    length: Optional[float] = Form(None),
    width: Optional[float] = Form(None),
    height: Optional[float] = Form(None),
    is_active: bool = Form(True),
    is_featured: bool = Form(False),
    track_inventory: bool = Form(True),

    # For VARIABLE products: JSON strings for complex nested data
    attributes: Optional[str] = Form(None, description="JSON array of attributes"),
    variants: Optional[str] = Form(None, description="JSON array of variants"),

    # Files
    main_images: List[UploadFile] = File(..., description="Product images (minimum 1 required)"),
    variant_images: Optional[List[UploadFile]] = File(None),

    # Other
    business_id: UUID = Query(..., description="Business ID"),
    db: Session = Depends(get_db),
    current_user: CurrentUser = Depends(get_current_user)
):
    """
    **FULL REPLACE UPDATE:** Updates product with complete replacement of all nested data.

    **IMPORTANT:**
    - SKU, product_code, and product_sequence are **immutable** and cannot be changed
    - product_type must match the original product type (SIMPLE cannot become VARIABLE, vice versa)
    - All old images, variants, and attributes will be **deleted** and replaced with new data
    - Physical image files will be deleted from storage
    - Use same format as create endpoint

    **For SIMPLE product:**
    - name, base_price, selling_price, qty, etc
    - main_images: File[] (old images will be deleted)

    **For VARIABLE product:**
    - name, base_price, selling_price, etc
    - attributes: JSON string '[{"attribute_name":"Size","values":[{"value":"S"}]}]'
    - variants: JSON string '[{"attribute_values":{"Size":"S"},"qty":10}]'
    - main_images: File[]
    - variant_images: File[] (with naming: variant_0_img.jpg)
    - All old variants and their images will be deleted
    """
    return await ProductController.update_product_with_form(
        product_id=product_id,
        name=name,
        product_type=product_type,
        base_price=base_price,
        selling_price=selling_price,
        description=description,
        category_id=category_id,
        qty=qty,
        min_stock=min_stock,
        max_stock=max_stock,
        weight=weight,
        length=length,
        width=width,
        height=height,
        is_active=is_active,
        is_featured=is_featured,
        track_inventory=track_inventory,
        attributes=attributes,
        variants=variants,
        main_images=main_images,
        variant_images=variant_images,
        business_id=business_id,
        updated_by=current_user.email,
        db=db
    )


@router.delete("/{product_id}", summary="Delete product")
def delete_product(
    product_id: UUID,
    business_id: UUID = Query(..., description="Business ID"),
    db: Session = Depends(get_db),
    current_user: CurrentUser = Depends(get_current_user)
):
    """
    Soft delete a product (sets deleted_at timestamp).
    """
    return ProductController.delete_product(
        product_id=product_id,
        business_id=business_id,
        deleted_by=current_user.email,
        db=db
    )
